# Shrimp Rules - Self-Healing Test Automation Harness

## Project Overview

This is a **Self-Healing Test Automation Harness** that orchestrates multiple test types with AI-powered healing capabilities. The system is built with TypeScript/Node.js and follows a plugin-based architecture for extensibility.

### Key Technologies
- **TypeScript/Node.js**: Core runtime and language
- **Express**: REST API framework
- **Playwright**: E2E testing engine
- **Jest/Vitest**: Unit testing engine
- **k6**: Performance testing engine
- **OWASP ZAP**: Security testing engine
- **Docker**: Containerization
- **OpenTelemetry**: Observability

### Success Criteria
- **60% healing success rate** for locator recovery
- **<500ms healing actions** for performance
- **<10 minutes setup time** for deployment
- **Unified reporting** across all test types

## Architecture

### Core Components
```
src/
├── core/           # Test orchestration and coordination
├── engines/        # Test engine implementations (Playwright, Jest, k6, ZAP)
├── healing/        # AI-powered self-healing algorithms
├── config/         # Configuration management (YAML-based)
├── api/            # REST API endpoints
├── observability/  # Metrics, logging, and monitoring
├── types/          # TypeScript type definitions
├── ui/             # Web dashboard and UI components
│   └── public/     # Static assets (HTML, CSS, JS)
└── utils/          # Shared utilities and helpers
```

### Plugin Architecture Pattern
- **Abstract Interfaces**: Define contracts for test engines
- **Base Classes**: Provide common functionality
- **Concrete Implementations**: Engine-specific logic
- **Registry Pattern**: Dynamic engine registration
- **Factory Pattern**: Engine instantiation

## Code Standards

### TypeScript Configuration
- **ALWAYS** use strict mode with all strict flags enabled
- **ALWAYS** use path aliases for clean imports (`@/core/*`, `@/engines/*`)
- **ALWAYS** implement proper error handling with custom error types
- **NEVER** use `any` type without explicit justification
- **ALWAYS** use interfaces for object shapes and contracts

### File Naming Conventions
- **Files**: kebab-case (`test-orchestrator.ts`, `healing-engine.ts`)
- **Classes**: PascalCase (`TestOrchestrator`, `HealingEngine`)
- **Functions/Variables**: camelCase (`executeTests`, `healingResult`)
- **Constants**: UPPER_CASE (`MAX_RETRIES`, `DEFAULT_TIMEOUT`)
- **Interfaces**: PascalCase with descriptive names (`TestEngine`, `HealingStrategy`)

### Import Organization
```typescript
// 1. Node.js built-ins
import fs from 'fs';
import path from 'path';

// 2. External dependencies
import express from 'express';
import yaml from 'js-yaml';

// 3. Internal modules (using path aliases)
import { TestEngine } from '@/types/engine';
import { logger } from '@/utils/logger';
import { config } from '@/config';
```

## Component Standards

### Test Engine Implementation
```typescript
// ALWAYS implement the TestEngine interface
interface TestEngine {
  readonly name: string;
  readonly version: string;
  readonly capabilities: EngineCapabilities;
  
  initialize(config: EngineConfig): Promise<void>;
  execute(tests: TestSpec[]): Promise<TestResult[]>;
  cleanup(): Promise<void>;
}

// ALWAYS extend the base engine class
abstract class BaseTestEngine implements TestEngine {
  protected config: EngineConfig;
  protected logger: Logger;
  
  constructor(config: EngineConfig) {
    this.config = config;
    this.logger = logger.child({ engine: this.name });
  }
  
  abstract execute(tests: TestSpec[]): Promise<TestResult[]>;
}
```

### Healing Strategy Implementation
```typescript
// ALWAYS implement confidence scoring
interface HealingStrategy {
  readonly name: string;
  readonly confidence: number; // 0-1 scale
  
  canHeal(failure: TestFailure): boolean;
  heal(failure: TestFailure): Promise<HealingResult>;
}

// ALWAYS provide fallback strategies
class LocatorHealingStrategy implements HealingStrategy {
  private strategies: HealingStrategy[] = [
    new IdFallbackStrategy(),
    new CssFallbackStrategy(),
    new XPathFallbackStrategy(),
    new NeighborAnalysisStrategy()
  ];
  
  async heal(failure: TestFailure): Promise<HealingResult> {
    for (const strategy of this.strategies) {
      if (strategy.canHeal(failure)) {
        const result = await strategy.heal(failure);
        if (result.confidence >= this.minConfidence) {
          return result;
        }
      }
    }
    throw new HealingFailedError('No suitable healing strategy found');
  }
}
```

### Configuration Management
```typescript
// ALWAYS use YAML configuration with validation
interface TestConfig {
  engines: EngineConfig[];
  healing: HealingConfig;
  observability: ObservabilityConfig;
  api: ApiConfig;
}

// ALWAYS validate configuration on load
class ConfigManager {
  loadConfig(path: string): TestConfig {
    try {
      const rawConfig = yaml.load(fs.readFileSync(path, 'utf8'));
      return this.validateConfig(rawConfig);
    } catch (error) {
      throw new ConfigError(`Failed to load config from ${path}`, error);
    }
  }
  
  private validateConfig(config: any): TestConfig {
    // ALWAYS validate required fields
    if (!config.engines || !Array.isArray(config.engines)) {
      throw new ConfigError('engines array is required');
    }
    
    // ALWAYS validate engine configurations
    for (const engine of config.engines) {
      this.validateEngineConfig(engine);
    }
    
    return config as TestConfig;
  }
}
```

## Service Layer Standards

### Orchestration Service
```typescript
// ALWAYS implement proper error handling and logging
class TestOrchestrator {
  private engines: Map<string, TestEngine> = new Map();
  private healingEngine: HealingEngine;
  
  async executeTests(config: TestConfig): Promise<TestResult[]> {
    const startTime = Date.now();
    this.logger.info('Starting test execution', { config });
    
    try {
      const results = await this.runEngines(config);
      const healedResults = await this.healingEngine.processFailures(results);
      
      const duration = Date.now() - startTime;
      this.logger.info('Test execution completed', { 
        duration, 
        totalTests: results.length,
        healedTests: healedResults.filter(r => r.healed).length
      });
      
      return healedResults;
    } catch (error) {
      this.logger.error('Test execution failed', { error });
      throw new TestExecutionError('Failed to execute tests', error);
    }
  }
}
```

### Healing Service
```typescript
// ALWAYS implement confidence-based healing
class HealingEngine {
  private strategies: HealingStrategy[] = [];
  private confidenceThreshold: number;
  
  async heal(failure: TestFailure): Promise<HealingResult> {
    this.logger.debug('Attempting to heal test failure', { failure });
    
    for (const strategy of this.strategies) {
      if (strategy.canHeal(failure)) {
        try {
          const result = await strategy.heal(failure);
          if (result.confidence >= this.confidenceThreshold) {
            this.logger.info('Healing successful', { 
              strategy: strategy.name, 
              confidence: result.confidence 
            });
            return result;
          }
        } catch (error) {
          this.logger.warn('Healing strategy failed', { 
            strategy: strategy.name, 
            error 
          });
        }
      }
    }
    
    throw new HealingFailedError('No suitable healing strategy found');
  }
}
```

## Advanced Testing Patterns

### UI Component Testing Standards
```typescript
// ALWAYS use test-friendly initialization for UI components
describe('TestExecutionInterface', () => {
  let testExecutionInterface: any;
  let apiService: any;
  let mockDocument: any;
  let mockWindow: any;

  beforeEach(async () => {
    // Use actual ApiService component (not mocks) for real data flow testing
    apiService = new ApiService({
      baseUrl: 'http://localhost:3000',
      timeout: 1000,
      retryAttempts: 1,
      enableLogging: false
    });

    // Comprehensive DOM mocking with all required methods
    mockDocument = {
      getElementById: jest.fn(),
      querySelector: jest.fn(),
      querySelectorAll: jest.fn(),
      createElement: jest.fn(() => ({
        className: '',
        textContent: '',
        style: {},
        addEventListener: jest.fn(),
        removeEventListener: jest.fn(),
        setAttribute: jest.fn(),
        getAttribute: jest.fn(),
        classList: {
          add: jest.fn(),
          remove: jest.fn(),
          toggle: jest.fn()
        }
      })),
      body: {
        appendChild: jest.fn(),
        insertAdjacentHTML: jest.fn()
      }
    };

    // Mock global objects with proper TypeScript casting
    (global as any).document = mockDocument;
    (global as any).window = mockWindow;
    (global as any).FormData = jest.fn().mockImplementation(() => ({
      get: jest.fn(),
      set: jest.fn(),
      append: jest.fn()
    }));

    // Use test-friendly initialization
    testExecutionInterface = new TestExecutionInterface(apiService, {
      autoInit: false,
      enableLogging: false,
      skipDOMInit: true
    });
    
    await testExecutionInterface.init();
  });

  afterEach(() => {
    jest.clearAllMocks();
    jest.clearAllTimers();
    jest.useRealTimers();
    
    if (testExecutionInterface) {
      testExecutionInterface.destroy();
    }
  });
});
```

### FormData Mocking Patterns
```typescript
// ALWAYS avoid recursion in FormData mocking
// ❌ WRONG: Creates stack overflow
const mockFormData = new Map([...]);
mockFormData.get = jest.fn((key) => mockFormData.get(key)); // Recursion!

// ✅ CORRECT: Use separate data store
const formDataValues = new Map([
  ['testName', 'E2E Test'],
  ['timeout', '300']
]);
const mockFormData = {
  get: jest.fn((key) => formDataValues.get(key))
};
```

### API Mocking Strategies
```typescript
// ALWAYS use strategic API mocking for different URL patterns
mockFetch.mockImplementation((url) => {
  if (url.includes('/api/v1/tests/execute')) {
    return Promise.resolve({
      ok: true,
      status: 202,
      headers: { get: () => 'application/json' },
      json: async () => ({
        success: true,
        data: { testId: 'test_123', status: 'accepted' }
      })
    });
  }
  
  if (url.includes('/api/v1/tests/engines')) {
    return Promise.resolve({
      ok: true,
      headers: { get: () => 'application/json' },
      json: async () => ({
        success: true,
        data: {
          engines: [
            { name: 'playwright', testType: 'e2e', supportsHealing: true },
            { name: 'jest', testType: 'unit', supportsHealing: false }
          ]
        }
      })
    });
  }
  
  // Default response for other requests
  return Promise.resolve({
    ok: true,
    headers: { get: () => 'application/json' },
    json: async () => ({ success: true, data: {} })
  });
});
```

## Custom Hook Standards

### Configuration Hooks
```typescript
// ALWAYS provide hooks for configuration changes
interface ConfigHooks {
  onEngineConfigChange: (engine: string, config: EngineConfig) => void;
  onHealingConfigChange: (config: HealingConfig) => void;
  onObservabilityConfigChange: (config: ObservabilityConfig) => void;
}

// ALWAYS implement hook registration
class ConfigManager {
  private hooks: ConfigHooks[] = [];
  
  registerHooks(hooks: ConfigHooks): void {
    this.hooks.push(hooks);
  }
  
  private notifyConfigChange(type: string, config: any): void {
    this.hooks.forEach(hooks => {
      try {
        hooks[type]?.(config);
      } catch (error) {
        this.logger.error('Config hook failed', { type, error });
      }
    });
  }
}
```

### Test Execution Hooks
```typescript
// ALWAYS provide hooks for test lifecycle events
interface TestHooks {
  onTestStart: (test: TestSpec) => void;
  onTestComplete: (result: TestResult) => void;
  onTestFailure: (failure: TestFailure) => void;
  onHealingAttempt: (attempt: HealingAttempt) => void;
}

// ALWAYS implement hook execution
class TestOrchestrator {
  private hooks: TestHooks[] = [];
  
  private async executeHooks<T extends keyof TestHooks>(
    hookName: T, 
    ...args: Parameters<TestHooks[T]>
  ): Promise<void> {
    for (const hooks of this.hooks) {
      try {
        await hooks[hookName]?.(...args);
      } catch (error) {
        this.logger.error('Test hook failed', { hookName, error });
      }
    }
  }
}
```

## Data Management

### Test Result Storage
```typescript
// ALWAYS use structured data formats
interface TestResult {
  id: string;
  testSpec: TestSpec;
  status: TestStatus;
  duration: number;
  timestamp: Date;
  metadata: Record<string, any>;
  healing?: HealingResult;
}

// ALWAYS implement proper serialization
class TestResultStorage {
  async store(result: TestResult): Promise<void> {
    const serialized = {
      ...result,
      timestamp: result.timestamp.toISOString(),
      metadata: JSON.stringify(result.metadata)
    };
    
    await this.database.insert('test_results', serialized);
  }
  
  async retrieve(id: string): Promise<TestResult> {
    const row = await this.database.select('test_results', { id });
    return this.deserialize(row);
  }
}
```

### Configuration Storage
```typescript
// ALWAYS support environment-specific configurations
interface EnvironmentConfig {
  development: TestConfig;
  staging: TestConfig;
  production: TestConfig;
}

// ALWAYS implement configuration inheritance
class ConfigManager {
  loadEnvironmentConfig(env: string): TestConfig {
    const baseConfig = this.loadConfig('config/base.yaml');
    const envConfig = this.loadConfig(`config/${env}.yaml`);
    
    return this.mergeConfigs(baseConfig, envConfig);
  }
}
```

## UI/Dashboard Standards

### Dashboard Architecture
```typescript
// ALWAYS use semantic HTML structure with proper ARIA labels
interface DashboardStructure {
  navigation: NavigationComponent;
  sections: DashboardSection[];
  realTimeUpdates: RealTimeDataService;
  responsiveDesign: ResponsiveLayout;
}

// ALWAYS implement mobile-first responsive design
class DashboardLayout {
  private breakpoints = {
    mobile: '480px',
    tablet: '768px',
    desktop: '1200px'
  };
  
  private gridSystem = {
    mobile: '1fr',
    tablet: 'repeat(2, 1fr)',
    desktop: 'repeat(3, 1fr)'
  };
}
```

### Test Execution Interface Implementation
```typescript
// ALWAYS implement test-friendly UI classes with dependency injection
class TestExecutionInterface {
  constructor(apiService, options = {}) {
    this.apiService = apiService;
    this.options = {
      autoInit: true,
      enableLogging: true,
      skipDOMInit: false,
      ...options
    };
    
    if (!this.apiService) {
      if (this.options.enableLogging) {
        console.error('TestExecutionInterface: ApiService is required');
      }
      return;
    }

    // Allow disabling auto-initialization for testing
    if (this.options.autoInit) {
      this.init();
    }
  }
  
  async init() {
    try {
      await this.loadAvailableEngines();
      
      // Skip DOM-dependent initialization in test environment
      if (!this.options.skipDOMInit) {
        this.setupEventListeners();
        this.setupTestConfigurationForm();
        await this.loadTestHistory();
      }
      
      this.isInitialized = true;
    } catch (error) {
      if (this.options.enableLogging) {
        console.error('Failed to initialize TestExecutionInterface:', error);
      }
    }
  }
  
  // ALWAYS implement proper cleanup to prevent memory leaks
  async onTestComplete(status) {
    try {
      const resultResponse = await this.apiService.getTestResult(this.currentTestId);
      // ... handle result display
    } catch (error) {
      if (this.options.enableLogging) {
        console.error('Failed to get test result:', error);
      }
    }

    // CRITICAL: Stop monitoring first to prevent memory leaks
    this.stopTestMonitoring();
    
    // Reset UI and refresh history
    this.resetExecutionUI();
    this.loadTestHistory();
  }
}
```

### UI Component Standards
```typescript
// ALWAYS use glassmorphism design patterns
:root {
  --primary-color: #667eea;
  --secondary-color: #764ba2;
  --background-glass: rgba(255, 255, 255, 0.1);
  --border-glass: rgba(255, 255, 255, 0.2);
  --shadow-light: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-medium: 0 8px 32px rgba(0, 0, 0, 0.1);
}

// ALWAYS implement proper accessibility
.navbar {
  role: 'navigation';
  'aria-label': 'Main navigation';
}

.nav-link {
  role: 'menuitem';
  'aria-current': 'page'; // when active
}
```

### Real-Time Data Integration
```typescript
// ALWAYS provide real-time updates with auto-refresh
class DashboardDataService {
  private refreshInterval = 30000; // 30 seconds
  private healthCheckInterval = 10000; // 10 seconds for health checks
  private visibilityApi = new VisibilityAPI();
  
  async loadSystemStatus(): Promise<SystemStatus> {
    try {
      const response = await fetch('/health');
      return await response.json();
    } catch (error) {
      this.showNotification('Failed to load system status', 'error');
      throw error;
    }
  }
  
  startAutoRefresh(): void {
    // Different intervals for different data types
    this.systemHealthTimer = setInterval(() => {
      if (!document.hidden) {
        this.loadSystemStatus();
      }
    }, this.healthCheckInterval);
    
    this.engineStatusTimer = setInterval(() => {
      if (!document.hidden) {
        this.loadEngineStatus();
      }
    }, this.refreshInterval);
  }
  
  stopAutoRefresh(): void {
    if (this.systemHealthTimer) clearInterval(this.systemHealthTimer);
    if (this.engineStatusTimer) clearInterval(this.engineStatusTimer);
  }
}
```

### Navigation and Routing
```typescript
// ALWAYS implement single-page application navigation
class DashboardNavigation {
  private sections: Map<string, DashboardSection> = new Map();
  private currentSection: string = 'overview';
  
  showSection(sectionId: string): void {
    // Hide all sections
    this.sections.forEach(section => section.hide());
    
    // Show target section
    const targetSection = this.sections.get(sectionId);
    if (targetSection) {
      targetSection.show();
      this.currentSection = sectionId;
      this.updateActiveNavLink(sectionId);
    }
  }
  
  private updateActiveNavLink(sectionId: string): void {
    document.querySelectorAll('.nav-link').forEach(link => {
      link.classList.remove('active');
      if (link.getAttribute('href') === `#${sectionId}`) {
        link.classList.add('active');
      }
    });
  }
}
```

### Error Handling and User Feedback
```typescript
// ALWAYS provide user feedback for all actions
class NotificationService {
  showNotification(message: string, type: 'success' | 'error' | 'warning' | 'info'): void {
    const notification = this.createNotificationElement(message, type);
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      notification.remove();
    }, 5000);
  }
  
  private createNotificationElement(message: string, type: string): HTMLElement {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    notification.textContent = message;
    
    // Apply glassmorphism styling
    Object.assign(notification.style, {
      position: 'fixed',
      top: '20px',
      right: '20px',
      padding: '1rem 1.5rem',
      borderRadius: '8px',
      background: 'var(--background-glass)',
      backdropFilter: 'blur(10px)',
      border: '1px solid var(--border-glass)',
      color: 'white',
      zIndex: '10000'
    });
    
    return notification;
  }
}
```

### Static File Serving Standards
```typescript
// ALWAYS set explicit MIME type headers for static files
app.use('/static', express.static(path.join(__dirname, 'ui/public'), {
  setHeaders: (res, path) => {
    if (path.endsWith('.css')) {
      res.setHeader('Content-Type', 'text/css');
    } else if (path.endsWith('.js')) {
      res.setHeader('Content-Type', 'text/javascript');
    } else if (path.endsWith('.html')) {
      res.setHeader('Content-Type', 'text/html');
    }
  }
}));

// ALWAYS use /static/ prefix in HTML files
// ✅ Correct: <link href="/static/css/dashboard.css" rel="stylesheet">
// ❌ Wrong:   <link href="css/dashboard.css" rel="stylesheet">
```

### Build Process Integration
```typescript
// ALWAYS remember: Server serves from dist/ directory
// Development workflow:
// 1. Edit files in src/ui/public/
// 2. Run: npm run build (copies to dist/ui/public/)
// 3. Restart server: npm start
// 4. Clear browser cache or use incognito mode

// Build script should include UI file copying:
// "build": "tsc && cp -r src/ui dist/"
```

## UI/UX Standards

### API Response Format
```typescript
// ALWAYS use consistent response format
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  metadata: {
    timestamp: string;
    requestId: string;
    duration: number;
  };
}

// ALWAYS implement proper error responses
class ApiController {
  private sendResponse<T>(res: Response, data: T, duration: number): void {
    const response: ApiResponse<T> = {
      success: true,
      data,
      metadata: {
        timestamp: new Date().toISOString(),
        requestId: res.locals.requestId,
        duration
      }
    };
    
    res.json(response);
  }
  
  private sendError(res: Response, error: Error, duration: number): void {
    const response: ApiResponse<never> = {
      success: false,
      error: {
        code: error.name,
        message: error.message,
        details: process.env.NODE_ENV === 'development' ? error.stack : undefined
      },
      metadata: {
        timestamp: new Date().toISOString(),
        requestId: res.locals.requestId,
        duration
      }
    };
    
    res.status(500).json(response);
  }
}
```

### Logging Standards
```typescript
// ALWAYS use structured logging
interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  context: {
    component: string;
    operation: string;
    requestId?: string;
    userId?: string;
  };
  data?: Record<string, any>;
}

// ALWAYS include relevant context
class Logger {
  child(context: Record<string, any>): Logger {
    return new Logger({ ...this.context, ...context });
  }
  
  info(message: string, data?: Record<string, any>): void {
    this.log('info', message, data);
  }
  
  error(message: string, error?: Error, data?: Record<string, any>): void {
    this.log('error', message, { ...data, error: error?.stack });
  }
}
```

## File Interaction Standards

### Configuration Files
- **ALWAYS** use YAML for configuration files
- **ALWAYS** validate configuration on load
- **ALWAYS** support environment-specific overrides
- **ALWAYS** provide default values for optional settings

### Test Files
- **ALWAYS** use descriptive test file names
- **ALWAYS** group related tests in the same file
- **ALWAYS** use consistent test structure (arrange, act, assert)
- **ALWAYS** include setup and teardown logic

### Documentation Files
- **ALWAYS** keep README.md up to date
- **ALWAYS** document API endpoints
- **ALWAYS** provide configuration examples
- **ALWAYS** include troubleshooting guides

## Development Workflow

### Git Workflow
- **ALWAYS** use conventional commits
- **ALWAYS** create feature branches
- **ALWAYS** run tests before committing
- **ALWAYS** update documentation with changes

### Testing Workflow
- **ALWAYS** write unit tests for new features
- **ALWAYS** write integration tests for API endpoints
- **ALWAYS** test healing strategies with mock failures
- **ALWAYS** validate configuration changes
- **ALWAYS** use real components in tests (not full mocks) when possible
- **ALWAYS** type mock objects as `any` to avoid TypeScript conflicts
- **ALWAYS** mock DOM methods comprehensively (`addEventListener`, `createElement`, etc.)
- **ALWAYS** test asynchronous initialization and data loading patterns
- **ALWAYS** implement test-friendly architecture with dependency injection
- **ALWAYS** separate DOM initialization from core logic for better testability
- **ALWAYS** use comprehensive DOM mocking with all required methods
- **ALWAYS** mock global objects with proper TypeScript casting
- **ALWAYS** test UI components with real API service integration
- **ALWAYS** use unique variable names for global test declarations (e.g., `apiServiceMockFetch` not `mockFetch`)
- **ALWAYS** check for existing global declarations before creating new test files: `grep -r "const mockFetch" tests/`

### Deployment Workflow
- **ALWAYS** use Docker for deployment
- **ALWAYS** validate configuration in staging
- **ALWAYS** monitor healing success rates
- **ALWAYS** have rollback procedures

## Prohibited Actions

### NEVER Do These
- **NEVER** hardcode test engine logic in core components
- **NEVER** skip error handling in critical paths
- **NEVER** implement healing without confidence scoring
- **NEVER** create circular dependencies between modules
- **NEVER** ignore TypeScript strict mode warnings
- **NEVER** commit sensitive configuration data
- **NEVER** bypass the plugin architecture
- **NEVER** implement healing strategies without fallbacks
- **NEVER** hardcode API endpoints in frontend code
- **NEVER** skip accessibility features in UI components
- **NEVER** ignore mobile responsiveness in dashboard design
- **NEVER** implement UI without proper error handling and user feedback
- **NEVER** use relative paths for CSS/JS in HTML (always use `/static/` prefix)
- **NEVER** skip MIME type headers in Express.js static file serving
- **NEVER** forget to rebuild (`npm run build`) after UI changes
- **NEVER** implement UI classes without test-friendly architecture
- **NEVER** create monitoring intervals without proper cleanup (memory leaks)
- **NEVER** use over-mocking in tests when actual components provide better coverage
- **NEVER** implement UI components without comprehensive unit testing
- **NEVER** use generic global variable names in tests (use context-specific names like `apiServiceMockFetch`)
- **NEVER** create test files without checking for existing global constant declarations

### Security Considerations
- **NEVER** expose sensitive configuration in logs
- **NEVER** allow arbitrary code execution in healing
- **ALWAYS** validate input parameters
- **ALWAYS** sanitize test results before storage
- **ALWAYS** use secure communication protocols
- **ALWAYS** implement proper authentication

## AI Decision-Making Standards

### When Implementing New Features
1. **Check existing patterns** in the codebase
2. **Follow the plugin architecture** for test engines
3. **Implement proper interfaces** before concrete classes
4. **Add comprehensive error handling** and logging
5. **Include observability hooks** for monitoring
6. **Write tests** for new functionality
7. **Update documentation** with changes

### When Refactoring
1. **Understand the impact** on other components
2. **Maintain backward compatibility** when possible
3. **Update all related tests** and documentation
4. **Verify healing strategies** still work correctly
5. **Check configuration compatibility**

### Priority Order for Decisions
1. **Safety**: Never break existing functionality
2. **Performance**: Maintain <500ms healing actions
3. **Reliability**: Achieve 60% healing success rate
4. **Maintainability**: Follow established patterns
5. **Extensibility**: Support new test engines easily

## Testing Success Metrics

### TestExecutionInterface Implementation Achievement
- **✅ 100% Test Suite Success**: 20/20 test suites passing
- **✅ 100% Individual Test Success**: 450/450 tests passing
- **✅ 32 Comprehensive UI Tests**: Complete coverage of TestExecutionInterface
- **✅ Production Bug Found & Fixed**: Memory leak in monitoring intervals
- **✅ Performance Excellence**: 6.683 seconds for 450 tests
- **✅ Zero Regressions**: All existing tests maintained

### Test Results Visualization Implementation Achievement
- **✅ 100% Test Suite Success**: 28/28 test suites passing
- **✅ 100% Individual Test Success**: 651/651 tests passing
- **✅ 33 Comprehensive UI Tests**: Complete coverage of TestResultsVisualization
- **✅ Global Declaration Conflicts Resolved**: Fixed TypeScript redeclaration issues
- **✅ Performance Excellence**: 10.479 seconds for 651 tests
- **✅ Zero Regressions**: All existing functionality maintained
- **✅ Production-Ready Feature**: Complete test results visualization with artifacts, filtering, and healing views

### Testing Pattern Success Rates
- **✅ Async Initialization**: Fixed hanging issues with skipDOMInit pattern
- **✅ DOM Mocking**: Comprehensive mocking with all required methods
- **✅ TypeScript Compliance**: Proper global object casting patterns
- **✅ FormData Handling**: Stack overflow prevention with proper mocking
- **✅ API Integration**: Real component testing with strategic mocking
- **✅ Real-time Monitoring**: Timer and polling functionality testing
- **✅ Global Declaration Conflicts**: Prevention patterns for TypeScript variable scope issues
- **✅ Test Results Visualization**: Complete UI component with 33 comprehensive tests

### Architecture Quality Improvements
- **✅ Dependency Injection**: Test-friendly constructor options
- **✅ Separation of Concerns**: DOM initialization separated from core logic
- **✅ Memory Management**: Proper cleanup to prevent leaks
- **✅ Error Handling**: Graceful fallbacks for missing DOM elements
- **✅ Logging Control**: Optional logging for test environments

---

**Remember**: This is a self-healing test automation system. Every decision should consider how it affects the overall healing capabilities, system reliability, and the ability to maintain tests with minimal manual intervention. Our comprehensive testing approach ensures production-ready code with 100% test coverage and zero regressions.
